---
    published: false
    layout: html.presentation
    title: Веб-компоненты&#58; 4 года спустя
    description: SECON'2017. Презентация к докладу
    categories: [presentations]
    tags: [web components, html templates, html imports, shadow dom, custom elements, polymer]
---


<section markdown="1">

{: .highlight }
# [WEB COMPONENTS](http://w3c.github.io/webcomponents/explainer/)

## 4 года спустя

{: .highlight }
### http://goo.gl/BlIWaB

{: .text-center }
[<i class="fa fa-2x fa-qrcode"
    title="QR-код страницы"
    data-toggle="modal" data-target="#modal-qr"></i>](#)


</section>

<!-- 01 -------------------------------------------------------------------- -->

<section markdown="1">

## [Web Components](http://w3c.github.io/webcomponents/explainer/)

{: .text-center }
[Shadow DOM](http://w3c.github.io/webcomponents/spec/shadow/), [Custom Elements](http://w3c.github.io/webcomponents/spec/custom/), [HTML Templates](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html), [HTML Imports](http://w3c.github.io/webcomponents/spec/imports/)

Предоставляют нативные средства разработки компонент,
аналогичных стандартным DOM-элементам с точки зрения браузера.

[Web Components](http://w3c.github.io/webcomponents/explainer/) впервые реализованы 4 года назад в Google Chrome.

Прогресс в веб-технологиях:

*   {: .fragment .highlight-current-blue }
    архитектура:  
    — концепция "веб-сайт" сменилась на "веб-приложение"  
    — фронтенд стал независимой архитектурной частью

*   {: .fragment .highlight-current-blue }
    необходимость применения общепринятых архитектурных принципов и решений для фронтенда:  
    модели, контроллеры, представления, роутинги, хранилище состояния, выделять реиспользуемые модули и компоненты

*   {: .fragment .highlight-current-blue }
    создание средств реализации этих принципов и решений:  
    — систем сборки, транспайлеров, css-препроцессоров  
    — js-фреймворков уровня приложения со своими реализациями архитектурных решений

{: .fragment .highlight-current-blue }
**Все необходимое реализовано и применяется - зачем нужны вебкомпоненты?**

</section>

<!-- 02 -------------------------------------------------------------------- -->

<section markdown="1">

## [Web Components](http://w3c.github.io/webcomponents/explainer/): развитие

Развитие фронтенд-тулинга форсировало прогресс браузерных технологий.  
Ускорилась разработка w3c/ecmascript-стандартов и их имплементация в браузерах.  

Появились новые версии спецификаций
[Shadow DOM v.1](http://caniuse.com/#feat=shadowdomv1) и
[Custom Elements v.1](http://caniuse.com/#feat=custom-elementsv1),
вышел [Polymer v.2](https://www.polymer-project.org/2.0/docs/about_20)

-----------------------------------------------------|------------------------------------------------------------------------------------------------------------
[Shadow DOM v1](http://caniuse.com/#feat=shadowdomv1)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/4667415417847808)
[Custom Elements v1](http://caniuse.com/#feat=custom-elementsv1)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/4696261944934400)
[HTML Templates](http://caniuse.com/#feat=template)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/5207287069147136) [<i class="fa fa-firefox"/>](http://bugzil.la/818976) [<i class="fa fa-safari"/>](https://bugs.webkit.org/show_bug.cgi?id=123851) [<i class="fa fa-edge"/>](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/templateelement/)
[HTML Imports](http://caniuse.com/#feat=imports)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/5144752345317376)
*[Polymer v2](https://www.polymer-project.org/2.0/docs/about_20)*|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/> <i class="fa fa-firefox"/> <i class="fa fa-safari"/> <i class="fa fa-edge"/> <i class="fa fa-internet-explorer"/>](https://www.polymer-project.org/2.0/docs/about_20#browser-support-and-polyfills)

</section>

<!-- 03 -------------------------------------------------------------------- -->

<section markdown="1">

## [Shadow DOM: `v.0` vs `v.1`](https://hayato.io/2016/shadowdomv1/)

*   {: .fragment .highlight-current-blue }
    создание shadow root  
    `v.0:` `element.createShadowRoot()`  
    `v.1:` `element.attachShadow({ mode: ... })`

*   {: .fragment .highlight-current-blue }
    поддержка множественных shadow root  
    `v.0:` поддерживается  
    `v.1:` не поддерживается

*   {: .fragment .highlight-current-blue}
    closed shadow root  
    `v.0:` не поддерживается, shadow root постоянно доступен извне: `e.shadowRoot`  
    `v.1:` режим задается: `element.attachShadow({ mode: 'open' || 'closed' })`  
    работа геттеров `e.shadowRoot`, `e.assignedSlot` зависит от режима

*   {: .fragment .highlight-current-blue }
    shadow host  
    `v.0:` любой элемент может стать shadow host  
    `v.1:` [список элементов регламентирован](https://dom.spec.whatwg.org/#dom-element-attachshadow)

*   {: .fragment .highlight-current-blue }
    механизм распределения контента -
    позиции отображения контента из другого дерева:  
    `v.0:` Insertion points  
    `v.1:` Slots

</section>

<!-- 04 -------------------------------------------------------------------- -->

<section markdown="1">

## [Custom Elements: `v.0` vs `v.1`](https://github.com/shawnbot/custom-elements)

*   {: .fragment .highlight-current-blue }
    описание пользовательского элемента v.0 и v.1 в виде класса:  
    `class ElementClass extends HTMLElement {}`

*   {: .fragment .highlight-current-blue }
    регистрация элемента  
    `v.0:` `window.document.registerElement('my-element', MyElement)`  
    `v.1:` `window.customElements.define('my-element', MyElement)`

*   {: .fragment .highlight-current-blue }
    промис момента регистрации элемента  
    `v.1:` `customElements.whenDefined('my-element')`

*   {: .fragment .highlight-current-blue }
    определение конструктора класса элемента по его имени:  
    `v.1:` `customElements.get('element-name')`

*   жизненный цикл элемента:

{: .fragment .highlight-current-blue .no-border}
&nbsp;                 | Custom Elements v0         | Custom Elements v1
-----------------------|----------------------------|-------------------------
создание экземпляра    | `createdCallback`          | `constructor`
добавление в DOM       | `attachedCallback`         | `connectedCallback`
изменение атрибутов    | `attributeChangedCallback` | `attributeChangedCallback`
добавление в чужой DOM | —                          | `adoptedCallback`
удаление из DOM        | `detachedCallback`         | `disconnectedCallback`

</section>

<!-- 05 -------------------------------------------------------------------- -->

<section markdown="1">

## Сизифов труд

{: .fragment .highlight-current-blue .no-border}
`Вопрос:`
*   Кто делал свою реализацию дроп-дауна на:  
    `vanila-js / JQuery / NockoutJS / AngularJS / ReactJS / Angular2`

{: .fragment .highlight-current-blue .no-border}
Не пора ли остановиться?  

{: .fragment .highlight-current-blue .no-border}
Почему не написано UI-фреймворка, который можно использовать с любым фреймворком уровня приложения?  

{: .fragment .highlight-current-blue .no-border}
Один UI-фреймворк всеже есть и его использует каждый из нас.  

{: .fragment .highlight-current-blue .no-border}
`Вопрос:`
*   Какой это фреймворк?

</section>

<!-- 06 -------------------------------------------------------------------- -->

<section markdown="1">

## Нативные UI-компоненты браузера
`<button /><textarea /><select /><video /> <input type="text|checkbox|radio"/>`

Используя каждый из них вы не сомневаетесь будет ли он работать в вашем фреймворке.

{: .fragment .highlight-current-blue .no-border}
`Вопрос:` Что под капотом этого "фреймворка"?

Если открыть отладчик, включить `Show user agent shadow DOM`
и проинспектировать стандартные компоненты браузера - вы увидете что скрыто "под капотом".  

Да, это вебкомпоненты.  

{: .fragment .highlight-current-blue .no-border}
Почему эти компоненты работают везде?  
— реализованы на более низком уровне, чем js-фреймворк  
— используется Shadow DOM для изоляции собственного DOM-дерева компонента и его стилей  
— компонент предоставляет js-api и api атрибутов для взаимодействия с внешней средой

Имплементация стека стандартов Web Components предоставляет стандартное api, позволяющее
использовать эти "низкоуровневые" инструменты для создания собственных компонент.

</section>

<!-- 07 -------------------------------------------------------------------- -->

<section markdown="1">

## Web Components ~~vs~~ JS-framework

Сравнения по функционалу `Web Components vs JS-framework` корректны в той же степени,
что и `сравнение колеса с автомобилем` - тема одна и таже, на этом сходства заканчиваются.  

Относительно современных js-фреймворков по функционалу вебкомпоненты наиболее близки к ReactJS:
*   "из коробки" не содержат механизмов, типичных для application-фреймворков  
    (фреймворков уровня приложения - Angular, Ember):  
    роутинги, контроллеры, модели, хранилища состояния, ...
*   предоставляют лишь инструменты для создания компонент, не более того

**Основное назначение application-фреймворка:**  
— предоставить средства создания инфраструктуры приложения.

**Назначение вебкомпонентов:**  
— предоставить средства создания компонент.

**Не пора-ли начать использовать инструменты по их прямому назначению?**

</section>

<!-- 08 -------------------------------------------------------------------- -->

<section markdown="1">

## Web Components ~~||~~ JS-framework?

Нет необходимости отказываться от любимого фреймворка в пользу вебкомпонентов и наоборот.

Это выбор: `что мне выбрать: колеса или автомобиль?`  
Ответ очевиден: `автомобиль с колесами`  
А лучше: `автомобиль с колесами, которые можно менять и сменный комплект колес`  

Сегодня выбор application-фреймворка подразумевает и выбор ui-фреймворка:  
— для Angular-приложения - ui-фреймворк на Angular, для React-приложения - ...  
— смена фреймворка приложения приводит к замене наработанной базы ui-компонент.

На моей практике произошло:  
— purejs ➛ jquery  
— jquery ➛ KnockoutJS / jquery ➛ AngularJS / jquery ➛ ReactJS / jquery ➛ Angular2  
— AngularJS ➛ Angular2

Развитие application-фреймворков достаточно динамично, и хочется использовать самые прогрессивные из них.  
В тоже самое время от миграции на новый фреймворк нас останавливают значительные трудозатраты на переработку,
стилизацию, отладку и тестирование ui-компонент приложения.  

Зачастую заказчики продукта определяют стек фреймворков и технологий, которые должны использоваться для его реализации.
Причем считается что все необходимые ui-компоненты можно позаимствовать из числа уже реализованных, затратив
при том минимальное время на стилизацию и все доводы о трудозатратах на разработку выглядят не убедительно.  
Таикм образом, от пректа к проекту, происходит повторяющийся процесс разработки библиотеки ui-компонент проекта.

**Не пора ли остановиться?**


</section>

<!-- 09 -------------------------------------------------------------------- -->

<section markdown="1">

## Web Components && JS-framework?

Вебкомпоненты по своей сути можно использовать с любым js-фреймворком уровня приложения и ui-фреймворком:
*   с точки зрения фреймворка вебкомпоненты принципиально ничем не должны отличаться от нативных html-элементов,
    т.к. реализуются механизмами браузера - т.е. на более низком уровне, чем фреймфорк
*   современные фреймворки для рендеринга своих компонент и его синхронизации с DOM браузера
    используют свои реализации virtual DOM, которые находятся уровнем выше, чем Shadow DOM 
*   Shadow DOM вебкомпонентов не прозрачен для virtual DOM
*   вебкомпоненты работают со своим Shadow DOM-деревом, не оказывая влияния на virtual DOM фреймворка
*   процессы, протекающие внутри вебкомпонентов,
    изолированы от внешнего влияния и наоборот - сами не оказывают влияния на внешнюю среду фреймворка
*   взаимодействие вебкомпонентов с внешней средой фреймворка происходит через js-api вебкомпонента и его атрибуты

Вебкомпоненты предоставляют возможность использовать единую оттестированную, стабильную ui-билиотеку, которую можно
использовать в качестве bootstrap для любого web-приложения.

</section>

<!-- 10 -------------------------------------------------------------------- -->

<section markdown="1">

## [Polymer: возможности](https://www.polymer-project.org/2.0/docs/about_20)

Polymer предоставляет средства создания компонент, 


</section>

<!-- 05 -------------------------------------------------------------------- -->

<section markdown="1">

## [Polymer: `v.1` vs `v.2`](https://www.polymer-project.org/2.0/docs/about_20)

*   {: .fragment .highlight-current-blue }
    поддержка Shadow DOM v.1, Custom Elements v.1

*   {: .fragment .highlight-current-blue }
    **больше не поддерживается** "расширение" нативных элементов (`<input is="my-input">`)

*   {: .fragment .highlight-current-blue }
    реализован слой совместимости с Polymer v.1

*   {: .fragment .highlight-current-blue }
    использование ES6-классов для создания компонент,
    поддержка создания компонент с использованием фабрики для совместимости с `v.1`

*   {: .fragment .highlight-current-blue }
    жизненный цикл
    для class-based компонентов аналогичнен Custom Elements v.1,  
    для fabric-based компонентов поддерживается жизненный цикл Polymer v.1

{: .table }
&nbsp;              | Polymer v1 (fabric-based) | Polymer v2 (class-based)
--------------------|---------------------------|---------------------------
создание экземпляра | `created`                 | `constructor`
добавление в DOM    | `attached`                | `connectedCallback`
изменение атрибутов | `attributeChanged`        | `attributeChangedCallback`
удаление из DOM     | `detached`                | `disconnectedCallback`
готовоность DOM     | `ready`                   | `ready`

</section>

<!-- 06 -------------------------------------------------------------------- -->

<section markdown="1">

### [Polymer: возможности](https://www.polymer-project.org/2.0/docs/about_20)

Polymer предоставляет средства создания компонент, 

</section>

<!-- 07 -------------------------------------------------------------------- -->

<section markdown="1">

### [Polymer: улучшения в v.1](https://www.polymer-project.org/2.0/docs/about_20)

</section>

<!-- 08 -------------------------------------------------------------------- -->

<section markdown="1">

### [Polymer: `v.1` vs `v.2`](https://www.polymer-project.org/2.0/docs/about_20)

</section>

<!-- 09 -------------------------------------------------------------------- -->

<section markdown="1">

### [Polymer: Shady DOM](https://www.polymer-project.org/blog/shadydom)

</section>

<!-- 10 -------------------------------------------------------------------- -->

<section markdown="1">

## [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)

</section>

<!-- XX -------------------------------------------------------------------- -->

<section markdown="1">

## [Заголовок]()

*   {: .fragment .highlight-current-blue }
    **пункт**

*   {: .fragment .highlight-current-blue }
    **пункт**

*   {: .fragment .highlight-current-blue }
    **пункт**


</section>



