---
    published: false
    layout: html.default.post
    title: Вебкомпоненты&#58; 4 года спустя
    description: SECON'2017. Доклад
    categories: [blog]
    tags: [web components, html templates, html imports, shadow dom, custom elements, polymer]
---


## Введение

Вебкомпоненты предоставляют нативные (браузерные) средства разработки
расширяемых и ре-используемых компонент,
аналогичных стандартным DOM-элементам с точки зрения браузера.  
Содержат средства описания шаблона, стилей и логики компонента,
а также механизм их инкапсуляции в единую независимую сущность.

4 года назад в Google Chrome были реализованы пилотные варианты спецификаций W3C [Web Components](http://w3c.github.io/webcomponents/explainer/):
[Shadow DOM](http://w3c.github.io/webcomponents/spec/shadow/),
[HTML Imports](http://w3c.github.io/webcomponents/spec/imports/),
[Custom Elements](http://w3c.github.io/webcomponents/spec/custom/),
[HTML Templates](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/)

За это время произошли глобальные изменения в архитектуре веб-приложений:
*   устарела концепция "веб-сайт"  
    (веб-приложение с серверным рендерингом страниц, где фронтенд-технологии применялись для интерфейсных улучшений)
*   на смену ей пришла концепция "spa-приложение",  
    в которой произошло разделение на бекенд и фронтенд, которые взаимодействуют через API

Для построения фронтенда как независимой архитектурной части web-приложения
стало необходимо применять общепринятые архитектурные принципы и решения:
*   модели, контроллеры, представления, логику их взаимодействия
*   роутинги, хранилище состояния приложения
*   выделять реиспользуемые модули и компоненты

Все это послужило толчком для создания средств для реализации этих принципов и решений.
Появились и широко используются:
*   системы сборки (Grunt/Gulp/Webpack)
*   транспайлеры (Babel/TypeScript)
*   css-препроцессоры (LESS/SASS/SCSS/PostCSS)
*   библиотеки CSS-in-JS
*   высокопроизводительные js-фреймворки (Angular/React/Ember),  
    предоставляющие свои реализации архитектурных решений

Этот прогресс нивелировал актуальность вебкомпонентов
и сейчас необходимость их применения кажется очень сомнительной.
Действительно, все перечисленные выше средства в совокупности
позволяют решить задачу разработки UI-компонент с инкапсулированными
шаблоном, стилями, логикой и состоянием.

Какое место претендуют занять вебкомпоненты в современном стеке фронтенд-технологий?
Зачем и как применять вебкомпоненты в jquery/angular/react/<ваш_фреймворк>-приложениях?



## [Web Components](http://w3c.github.io/webcomponents/explainer/)

### Что нового

Развитие фронтенд-тулинга форсировало прогресс браузерных технологий.  
Ускорилась разработка w3c/ecmascript-стандартов и их имплементация в браузерах.  
Стек стандартов Web Components тоже не остался без внимания.  
За прошедшие 4 года с момента экспериментальной реализации стека Web Components в Google Chrome:
*   вышли новые версии спецификаций [Shadow DOM v1](http://caniuse.com/#feat=shadowdomv1) и
    [Custom Elements v1](http://caniuse.com/#feat=custom-elementsv1)
*   [HTML Templates](http://caniuse.com/#feat=template) реализованы во всех основных браузерах, кроме IE
*   [HTML Imports](http://caniuse.com/#feat=imports)

-----------------------------------------------------|------------------------------------------------------------------------------------------------------------
[Shadow DOM v1](http://caniuse.com/#feat=shadowdomv1) &nbsp;|[<i class="fa fa-2x fa-chrome"/> <i class="fa fa-2x fa-opera"/>](https://www.chromestatus.com/features/4667415417847808)
[Custom Elements v1](http://caniuse.com/#feat=custom-elementsv1) &nbsp;|[<i class="fa fa-2x fa-chrome"/> <i class="fa fa-2x fa-opera"/>](https://www.chromestatus.com/features/4696261944934400)
[HTML Templates](http://caniuse.com/#feat=template) &nbsp;|[<i class="fa fa-2x fa-chrome"/> <i class="fa fa-2x fa-opera"/>](https://www.chromestatus.com/features/5207287069147136) [<i class="fa fa-2x fa-firefox"/>](http://bugzil.la/818976) [<i class="fa fa-2x fa-safari"/>](https://bugs.webkit.org/show_bug.cgi?id=123851) [<i class="fa fa-2x fa-edge"/>](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/templateelement/)
[HTML Imports](http://caniuse.com/#feat=imports) &nbsp;|[<i class="fa fa-2x fa-chrome"/> <i class="fa fa-2x fa-opera"/>](https://www.chromestatus.com/features/5144752345317376)


### Shadow DOM v0 vs v1
Наибольшие изменения претерпела спецификация Shadow DOM

*   создание shadow root  
    `v.0:` `element.createShadowRoot()`  
    `v.1:` `element.attachShadow({ mode: ... })`

*   поддержка множественных shadow root  
    `v.0:` поддерживается  
    `v.1:` не поддерживается

*   closed shadow root  
    `v.0:` не поддерживается, shadow root постоянно доступен извне: `e.shadowRoot`  
    `v.1:` режим задается: `element.attachShadow({ mode: 'open' || 'closed' })`  
    работа геттеров `e.shadowRoot`, `e.assignedSlot` зависит от режима

*   **shadow host**  
    `v.0:` любой элемент может стать shadow host  
    `v.1:` [список элементов регламентирован](https://dom.spec.whatwg.org/#dom-element-attachshadow)

*   механизм распределения контента -
    позиции отображения контента из другого дерева:  
    `v.0:` Insertion points  
    `v.1:` Slots


### [Custom Elements `v.0` vs `v.1`](https://github.com/shawnbot/custom-elements)

*   появление в браузерах поддержки es6 классов позволяет описывать
    пользовательский элемент v0 и v1 в виде класса:  
    `class ElementClass extends HTMLElement {}`

*   регистрация элемента  
    `v.0:` `window.document.registerElement('my-element', MyElement)`  
    `v.1:` `window.customElements.define('my-element', MyElement)`

*   промис момента регистрации элемента  
    `v.1:` `customElements.whenDefined('my-element')`

*   определение конструктора класса элемента по его имени:  
    `v.1:` `customElements.get('element-name')`

*   жизненный цикл элемента:
  
{: .table }
&nbsp;                 | Custom Elements v0         | Custom Elements v1
-----------------------|----------------------------|---------------------------
создание экземпляра    | `createdCallback`          | `constructor`
добавление в DOM       | `attachedCallback`         | `connectedCallback`
изменение атрибутов    | `attributeChangedCallback` | `attributeChangedCallback`
добавление в чужой DOM | —                          | `adoptedCallback`
удаление из DOM        | `detachedCallback`         | `disconnectedCallback`


### Зачем использовать вебкомпоненты?

`Вопрос:` Кто делал свою реализацию дроп-дауна на:

*   vanila-js
*   JQuery
*   NockoutJS
*   AngularJS
*   ReactJS
*   Angular2

**Не пора ли остановиться?**  
Написаны десятки UI-фреймворков, содержащие тысячи компонент.  
Подсчет человеко-часов, затраченных на этот титанический труд, не поддается оценке.  
Почему не написано UI-фреймворка, который можно использовать с любым фреймворком уровня приложения?  

Один UI-фреймворк всеже есть и его использует каждый из нас.  
`Вопрос:` Какой это фреймворк?  

Это нативные UI-компоненты браузера:

~~~html
<button />
<input type="text"/>
<input type="checkbox" />
<input type="radio" />
<textarea />
<select />
<video />
...
~~~

Используя каждый из них вы не сомневаетесь будет ли он работать в вашем фреймворке.

`Вопрос:` Что под капотом этого "фреймворка"?  
Если открыть отладчик, включить `Show user agent shadow DOM`
и проинспектировать стандартные компоненты браузера - вы увидете что скрыто "под капотом".  

Да, это вебкомпоненты.  

Почему эти компоненты работают везде?
— реализованы на более низком уровне, чем js-фреймворк  
— используется Shadow DOM для изоляции собственного DOM-дерева компонента и его стилей  
— компонент предоставляет js-api и api атрибутов для взаимодействия с внешней средой

Имплементация стека стандартов Web Components предоставляет стандартное api, позволяющее
использовать эти "низкоуровневые" инструменты для создания собственных компонент.



## Web Components <> JS-frameworks


### Web Components ~~vs~~ JS-framework

Сравнения по функционалу `Web Components vs JS-framework` корректны в той же степени,
что и сравнение `колеса с автомобилем` - тема одна и таже, на этом сходства заканчиваются.  
Обычно под js-фреймворком подразумевают application-фреймворк

Относительно современных js-фреймворков по функционалу вебкомпоненты наиболее близки к ReactJS:
*   "из коробки" не содержат механизмов, типичных для application-фреймворков (фреймворков уровня приложения),
    таких как Angular, Ember: роутинги, контроллеры, модели, хранилища состояния, ...
*   предоставляют лишь инструменты для создания компонент, не более того

Основное назначение application-фреймворка: предоставить средства создания инфраструктуры приложения.
Назначение вебкомпонентов: предоставить средства создания компонент.

**Не пора-ли начать использовать инструменты по их прямому назначению?**


### Что выбрать: Web Components или JS-framework?

Вам не придется делать этот выбор.  
Нет необходимости отказываться от любимого фреймворка в пользу вебкомпонентов и наоборот.

Это выбор: `что мне выбрать: колеса или автомобиль?`  
Ответ очевиден: `автомобиль с колесами`  
А лучше: `автомобиль с колесами, которые можно менять и сменный комплект колес`  

Действительно, выбор application-фреймворка обуславливает и выбор ui-фреймворка:
для Angular-приложения - ui-фреймворк на Angular, для React-приложения - ...  
Каждый раз меняя фреймворк приложения мы вынуждены менять всю наработанную базу ui-компонент.

На моей практике произошло:
*   purejs -> jquery
*   jquery -> KnockoutJS
*   jquery -> AngularJS
*   jquery -> ReactJS
*   AngularJS -> Angular2
*   jquery -> Angular2

Вебкомпоненты по своей сути можно использовать с любым js-фреймворком уровня приложения и ui-фреймворком:
*   с точки зрения фреймворка вебкомпоненты принципиально ничем не должны отличаться от нативных html-элементов,
    т.к. реализуются механизмами браузера - т.е. на более низком уровне, чем фреймфорк
*   современные фреймворки для рендеринга своих компонент и его синхронизации с DOM браузера
    используют свои реализации virtual DOM, которые находятся уровнем выше, чем Shadow DOM 
*   Shadow DOM вебкомпонентов не прозрачен для virtual DOM
*   вебкомпоненты работают со своим Shadow DOM-деревом, не оказывая влияния на virtual DOM фреймворка
*   процессы, протекающие внутри вебкомпонентов,
    изолированы от внешнего влияния и наоборот - сами не оказывают влияния на внешнюю среду фреймворка
*   взаимодействие вебкомпонентов с внешней средой фреймворка происходит через js-api вебкомпонента и его атрибуты

Развитие application-фреймворков достаточно динамично, и хочется использовать самые прогрессивные из них.  
В тоже самое время от миграции на новый фреймворк нас останавливают значительные трудозатраты на переработку,
стилизацию, отладку и тестирование ui-компонент приложения.  

Зачастую заказчики продукта определяют стек фреймворков и технологий, которые должны использоваться для его реализации.
Причем считается что все необходимые ui-компоненты можно позаимствовать из числа уже реализованных, затратив
при том минимальное время на стилизацию и все доводы о трудозатратах на разработку выглядят не убедительно.  
Таикм образом, от пректа к проекту, происходит повторяющийся процесс разработки библиотеки ui-компонент проекта.

Использование библиотеки ui-вебкомпонент стало бы разумным решением.  
Вебкомпоненты предоставляют возможность использовать единую оттестированную, стабильную ui-билиотеку, которую можно
использовать в качестве bootstrap для любого web-приложения.


### Кто использует стандарты Web Components?
*   Google  
    толкает локомотив прогресса, основной разработчик стандартов Web Components
*   Angular2  
    Shadow DOM - режим изоляции шаблонов
*   [Vaadin](https://vaadin.com) и его [компоненты](https://www.webcomponents.org/author/vaadin)  
    — Works on any HTML5 based stack  
    — Supports Polymer and Angular 2 data binding



## Polymer


### [Polymer: миссия](https://www.polymer-project.org/2.0/docs/devguide/feature-overview)

Polymer предоставляет возможность использовать вебкомпоненты уже сегодня.  
Представляет собой "прослойку" для безшовного перехода PolymerComponent <-> WebComponent и наоборот.

Возможности:

*   создание пользовательских элементов:  
    — регистрация пользовательского элемента, его ассоциация с именем и классом, описывающим
      жизненный цикл и логику работы элемента  
    — система каллбэков для управления жизненным циклом элемента  
    — использование property-api элемента для его интеграции с Polymer data system

*   использование Shadow DOM в polymer-компонентах:  
    — Shadow DOM позволяет создать локальное изолированное DOM-дерево пользовательского элемента  
    — позволяет создавать shadow-дерево пользовательского элемента на основе DOM-template

*   система событий  
    — декларативный синтаксис для добавления event listeners для элементов shadow DOM дерева  
    — библиотека для обработки событий-жестов

*   Data system
    — data binding для свойств и атрибутов  
    — property observers  
    — computed properties.


### [Polymer: улучшения в 2.0](https://www.polymer-project.org/2.0/docs/about_20)

*   **улучшена функциональная совместимость с библиотеками и фреймворками**:  
    — убрана необходимость использования Polymer.dom для манипуляций с DOM  
    — код Shadow DOM-полифила «[shady DOM](https://github.com/webcomponents/shadydom)» выведен из Polymer  
    — для манипуляций с DOM используется стандартный API спецификации Shadow DOM  

*   **улучшения в Data system** направлены на:  
    — упрощение распространения данных через/между элементами  
    — упрощение отладки распространения данных

*   **стандартизация**  
    — поддержка спецификаций Shadow DOM v.1, Custom Elements v.1  
    — использование ES6 классов и стандартных методов спецификации Custom Elements v.1 для описания polymer-компонента  
    — жизненный цикл polymer-компонента соответствует Custom Elements v.1  


### [Polymer: под капотом](https://www.webcomponents.org/polyfills/)

Пока поддержка стека Web Components реализована не всеми браузерами, Polymer использует набор полифилов,
объединенных в пакет [webcomponents-lite.js](https://github.com/WebComponents/webcomponentsjs):

*   полифилы поддержки Shadow DOM:
    «[Shady DOM](https://github.com/webcomponents/shadydom)»,
    «[Shady CSS](https://github.com/webcomponents/shadycss)».
    
    [Shady DOM](https://www.polymer-project.org/blog/shadydom): зачем понадобился еще один полифил Shadow DOM?  
    Главная задача полифилов Shadow DOM заключается в изоляции теневого DOM (исключение влияния извне и наоборот).  
    Существующие полифилы Shadow DOM достаточно сложны и медленны в работе.  
    Shady DOM представляет собой shim для Shadow DOM, реализующий (с некоторыми ограничениями) изоляцию
    теневого дерева без ущерба производительности и предоставляющий API в соответствии со спецификацией Shadow DOM.

*   [полифил поддержки Custom Elements](https://github.com/webcomponents/custom-elements)
*   [полифил поддержки HTML Imports](https://github.com/webcomponents/html-imports)
*   [полифил поддержки HTML Templates](https://github.com/webcomponents/template)

Все эти полифилы реализованы с учетом:
*   минимизации ущерба производительности  
*   максимальной совместимости по API со стеком стандартов Web Components
*   перехода на использования браузерных реализаций вебкомпонентов при их наличии
*   упрощения использования Polymer с другими библиотеками и фреймворками

Полная совместимость по API со стеком стандартов Web Components позволяет "безшовно"
переключиться на использования браузерных реализаций вебкомпонентов при их наличии.


### [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)

Входит в тренд предоставление CLI-клиента для фреймворка.
Впервые CLI был реализован в Ember (2013), затем Angular (2015), Polymer (2016)

*   предоставляет boilerplate-генератор для 2-х типов проектов: компонент и приложение
*   предоставляет линтер, development server, test runner, сборщик проекта
*   использует Bower для управления зависимостями  
    ( имеет плоское дерево зависимостей, что позволет легко делать импорты по относительным путям )


## Библиотеки UI-компонент

[WEBCOMPONENTS.ORG](https://www.webcomponents.org/) - да, именно так, заглавными буквами.
Это единый репозиторий UI-компонент, созданных на базе технологий вебкомпонентов и Polymer:

*   [PolymerElements](https://www.webcomponents.org/author/PolymerElements)
    (elements.polymer-project.org)
*   [GoogleWebComponents](https://www.webcomponents.org/author/GoogleWebComponents)
    компоненты для работы с сервисами Google
    (входил в состав elements.polymer-project.org)
*   [Vaadin](https://www.webcomponents.org/author/vaadin)
