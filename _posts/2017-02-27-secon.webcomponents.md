---
    published: false
    layout: html.default.post
    title: Веб-компоненты&#58; 4 года спустя
    description: SECON'2017. Доклад
    categories: [blog]
    tags: [web components, html templates, html imports, shadow dom, custom elements, polymer]
---


## Сейчас
4 года назад в Google Chrome были реализованы пилотные варианты спецификаций W3C [Web Components](http://w3c.github.io/webcomponents/explainer/):
[Shadow DOM](http://w3c.github.io/webcomponents/spec/shadow/),
[HTML Imports](http://w3c.github.io/webcomponents/spec/imports/),
[Custom Elements](http://w3c.github.io/webcomponents/spec/custom/),
[HTML Templates](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/)

Веб-компоненты предоставляют нативные (браузерные) средства разработки
расширяемых и ре-используемых компонент,
аналогичных стандартным DOM-элементам с точки зрения браузера.
Содержат средства описания шаблона, стилей и логики компонента,
а также механизм их инкапсуляции в единую независимую сущность.

За это время произошли глобальные изменения в архитектуре веб-приложений:
*   устарела концепция "веб-сайт"  
    (веб-приложение с серверным рендерингом страниц, где фронтенд-технологии применялись для интерфейсных улучшений)
*   на смену ей пришла концепция "spa-приложение",  
    в которой произошло разделение на бекенд и фронтенд, которые взаимодействуют через API

Для построения фронтенда как независимой архитектурной части web-приложения
стало необходимо применять общепринятые архитектурные принципы и решения:
*   модели, контроллеры, представления, логику их взаимодействия
*   роутинги, хранилище состояния приложения
*   выделять реиспользуемые модули и компоненты

Все это послужило толчком для создания средств для реализации этих принципов и решений.
Появились и широко используются:
*   системы сборки (Grunt/Gulp/Webpack)
*   транспайлеры (Babel/TypeScript)
*   css-препроцессоры (LESS/SASS/SCSS/PostCSS)
*   библиотеки CSS-in-JS
*   высокопроизводительные js-фреймворки (Angular/React/Ember),  
    предоставляющие свои реализации архитектурных решений

Этот прогресс нивелировал актуальность веб-компонентов
и сейчас необходимость их применения кажется очень сомнительной.
Действительно, все перечисленные выше средства в совокупности
позволяют решить задачу разработки UI-компонент с инкапсулированными
шаблоном, стилями, логикой и состоянием.

Какое место претендуют занять веб-компоненты в современном стеке фронтенд-технологий?
Зачем и как применять веб-компоненты в jquery/angular/react/<ваш_фреймворк>-приложениях?



## [Web Components](http://w3c.github.io/webcomponents/explainer/)

Развитие фронтенд-тулинга послужило толчком прогресса браузерных технологий.  
Ускорилась имплементация w3c/es - стандартов в браузерах.  
Стек стандартов Web Components тоже не остался без внимания.  
За прошедшие 4 года с момента экспериментальной реализации стека Web Components в Google Chrome:
*   вышли новые версии спецификаций [Shadow DOM v1](http://caniuse.com/#feat=shadowdomv1) и
    [Custom Elements v1](http://caniuse.com/#feat=custom-elementsv1)
*   [HTML Templates](http://caniuse.com/#feat=template) реализованы во всех основных браузерах, кроме IE
*   [HTML Imports](http://caniuse.com/#feat=imports)

{: .table}
[Shadow DOM v1](http://caniuse.com/#feat=shadowdomv1)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/4667415417847808)
-----------------------------------------------------|------------------------------------------------------------------------------------------------------------
[Custom Elements v1](http://caniuse.com/#feat=custom-elementsv1)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/4696261944934400)
[HTML Templates](http://caniuse.com/#feat=template)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/5207287069147136) [<i class="fa fa-firefox"/>](http://bugzil.la/818976) [<i class="fa fa-safari"/>](https://bugs.webkit.org/show_bug.cgi?id=123851) [<i class="fa fa-edge"/>](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/templateelement/)
[HTML Imports](http://caniuse.com/#feat=imports)|[<i class="fa fa-chrome"/> <i class="fa fa-opera"/>](https://www.chromestatus.com/features/5144752345317376)


### Shadow DOM v0 vs v1
Наибольшие изменения претерпела спецификация Shadow DOM

*   создание shadow root  
    `v.0:` `element.createShadowRoot()`  
    `v.1:` `element.attachShadow({ mode: ... })`

*   поддержка множественных shadow root  
    `v.0:` поддерживается  
    `v.1:` не поддерживается

*   closed shadow root  
    `v.0:` не поддерживается, shadow root постоянно доступен извне: `e.shadowRoot`  
    `v.1:` режим задается: `element.attachShadow({ mode: 'open' || 'closed' })`  
    работа геттеров `e.shadowRoot`, `e.assignedSlot` зависит от режима

*   **shadow host**  
    `v.0:` любой элемент может стать shadow host  
    `v.1:` [список элементов регламентирован](https://dom.spec.whatwg.org/#dom-element-attachshadow)

*   механизм распределения контента -
    позиции отображения контента из другого дерева:  
    `v.0:` Insertion points  
    `v.1:` Slots


### [Custom Elements `v.0` vs `v.1`](https://github.com/shawnbot/custom-elements)

*   регистрация элемента  
    `v.0:` `window.document.registerElement('my-element', MyElement)`  
    `v.1:` `window.customElements.define('my-element', MyElement)`

*   промис момента регистрации элемента  
    `v.1:` `customElements.whenDefined('my-element')`

*   определение конструктора класса элемента по его имени:  
    `v.1:` `customElements.get('element-name')`

*   жизненный цикл элемента:
  
{: .table }
&nbsp;                 | Custom Elements v0         | Custom Elements v1
-----------------------|----------------------------|---------------------------
создание экземпляра    | `createdCallback`          | `constructor`
добавление в DOM       | `attachedCallback`         | `connectedCallback`
изменение атрибутов    | `attributeChangedCallback` | `attributeChangedCallback`
добавление в чужой DOM | —                          | `adoptedCallback`
удаление из DOM        | `detachedCallback`         | `disconnectedCallback`




## Polymer

### [Polymer: возможности](https://www.polymer-project.org/2.0/docs/about_20)

Polymer предоставляет средства создания пользовательских компонент, 

*   *вышел [Polymer 2.0](https://www.polymer-project.org/2.0/docs/about_20)*

### [Polymer: улучшения в v.1](https://www.polymer-project.org/2.0/docs/about_20)

*   **улучшена функциональная совместимость с библиотеками и фреймворками**:  
    — убрана необходимость использования Polymer.dom для манипуляций с DOM  
    — код Shadow DOM-полифила «Shady DOM» выведен из Polymer
    — для манипуляций с DOM используется стандартный API спецификации Shadow DOM  

*   **улучшения в Data system** направлены на:
    — упрощение распространения данных через/между элементами
    — упрощение отладки распространения данных

*   **стандартизация**  
    — поддержка спецификаций Shadow DOM v.1, Custom Elements v.1  
    — использование ES6 классов и стандартных методов спецификации Custom Elements v.1 для описания polymer-компонента  
    — жизненный цикл polymer-компонента соответствует Custom Elements v.1  

### [Polymer: `v.1` vs `v.2`](https://www.polymer-project.org/2.0/docs/about_20)

*   поддержка Shadow DOM v.1, Custom Elements v.1

*   **больше не поддерживается** "расширение" нативных элементов (`<input is="my-input">`)

*   использование ES6-классов для создания компонент,  
    поддержка создания компонент с использованием фабрики для совместимости с `v.1`

*   реализован слой совместимости с Polymer v.1

*   жизненный цикл
    для class-based компонентов аналогичнен Custom Elements v.1,  
    для fabric-based компонентов поддерживается жизненный цикл Polymer v.1

{: .table }
&nbsp;              | Polymer v1 (fabric-based) | Polymer v2 (class-based)
--------------------|---------------------------|---------------------------
создание экземпляра | `created`                 | `constructor`
добавление в DOM    | `attached`                | `connectedCallback`
изменение атрибутов | `attributeChanged`        | `attributeChangedCallback`
удаление из DOM     | `detached`                | `disconnectedCallback`
готовоность DOM     | `ready`                   | `ready`

### [Polymer: Shady DOM](https://habrahabr.ru/post/259187/)
https://github.com/webcomponents/shadydom
https://github.com/webcomponents/shadycss


### [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)

Мода, эмбер2013-ангуляр2015-полимер2016
2 типа проектов - компонент и приложение
boower - потомучто плоское дерево зависимостей, легко делать импорты по относительным путям


### Polymer: миссия
Polymer предоставляет возможность использовать веб-компоненты уже сегодня.
Представляет собой "прослойку" для безшовного перехода PolymerComponent <-> WebComponent и наоборот,
в своем роде "Babel/Lebab" для компонентов.

Стандартизация - одна из целей, поставленных при разработке Polymer v.2
— поддержка спецификаций Shadow DOM v.1, Custom Elements v.1  
— использование ES6 классов и стандартных методов спецификации Custom Elements v.1 для описания polymer-компонента  
— жизненный цикл polymer-компонента соответствует Custom Elements v.1  

## Web Components & JS-frameworks

### Web Components vs JS-framework
Сравнения `Web Components vs JS-framework`, `Polymer vs JS-framework` корректны в той же степени,
что и сравнения `ReactJS vs Angular`. `ReactJS vs Ember`.

Относительно существующего стека JS-фреймворков веб-компоненты наиболее близки к ReactJS:
*   предоставляют средства инкапсуляции верстки, стилей и логики работы компонента

{: .table }
&nbsp;                | Web Components  | ReactJS
----------------------|-----------------|--------
Верстка               | HTML Templates  | JSX
Средства инкапсуляции | Custom Elements | JSX


### Что выбрать: Web Components или JS-framework?
Считаю что вам не придется делать этот выбор.
Нет необходимости отказываться от любимого фреймворка в пользу веб-компонентов и наоборот.
Компоненты, разработанные на базе стандартов web components можно использовать с любым js-фреймворком:
*   с точки зрения браузера (и фреймворка) они принципиально ничем не должны отличаться от нативных html-элементов
*   они реализуются механизмами браузера - т.е. на более низком уровне, чем фреймфорк

Мы хотим стабильную ui билиотеку, которую можно использовать в динамично-развивающихся фреймворках
Развитие нативных вебкомпонентов как стека стандартов будет медленным.
Для фреймворков важна скорость внедрения фич.
ВК - для UI приложения, для инфраструктуры - фреймворки


### Реализация "чистого" веб-компонента

### JQuery & Web Components

Это самый простой случай

### React & Web Components
В существующем стеке JS-фреймворков веб-компоненты наиболее близки к ReactJS:
*   предоставляют средства инкапсуляции верстки, стилей и логики работы компонента

{: .table }
&nbsp;                | Web Components  | ReactJS
----------------------|-----------------|--------
Верстка               | HTML Templates  | JSX
Средства инкапсуляции | Custom Elements | JSX

### Angular2 & Web Components

Angular2: 3 режима инкапсуляции



## Polymer & JS-frameworks

### Библиотеки

### [Vaadin](https://vaadin.com)
*   Works on any HTML5 based stack.
*   Supports Polymer and Angular 2 data binding.